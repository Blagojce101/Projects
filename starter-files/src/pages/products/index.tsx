import Product from "@/Components/Product";
import SideFilterMenu from "@/Components/SideFilterMenu";
import { ProductType } from "@/interfaces/interfaces";
import { GetServerSideProps, NextPage } from "next";
import Head from "next/head";
import { useRouter } from "next/router";
import React, { useEffect, useState } from "react";

interface Props {
  productData: ProductType[];
}

export const LS_PRODUCTS = "products";

const ProductsPage: NextPage<Props> = ({ productData }) => {
  const [products, setProducts] = useState<ProductType[]>([]);
  const [openFilterMenu, setOpenFilterMenu] = useState<boolean>(false);
  const [currentPage, setCurrentPage] = useState<number>(1);

  const [sortOption, setSortOption] = useState<string>("");
  const [sortedProducts, setSortedProducts] = useState<ProductType[]>([]);

  const router = useRouter();

  useEffect(() => {
    if (localStorage.getItem(LS_PRODUCTS)) {
      const productsFromLS = JSON.parse(localStorage.getItem(LS_PRODUCTS)!);
      setProducts(productsFromLS);
    } else {
      fetch(`http://localhost:5001/products`)
        .then((res) => res.json())
        .then((data: ProductType[]) => {
          setProducts(data);
          localStorage.setItem(LS_PRODUCTS, JSON.stringify(data));
        });
    }
  }, []);

  const toggleOpeningFilterMenu = () => {
    setOpenFilterMenu(!openFilterMenu);
  };

  const closeFilterMenu = () => {
    setOpenFilterMenu(false);
  };

  const totalPages = Math.ceil(productData.length / 10);
  const start = (currentPage - 1) * 10;
  const end = start + 10;

  const paginationProductsForDisplaying = productData.slice(start, end);

  const handlePage = (page: number) => {
    setCurrentPage(page);
  };

  const sortProducts = (option: string) => {
    setSortOption(option);

    let sorted = [...productData];

    if (option === "најстаро") {
      sorted = sorted.sort(
        (a, b) =>
          new Date(a.dateCreated).getTime() - new Date(b.dateCreated).getTime()
      );
      setCurrentPage(1);
    } else if (option === "најново") {
      sorted = sorted.sort(
        (a, b) =>
          new Date(b.dateCreated).getTime() - new Date(a.dateCreated).getTime()
      );
      setCurrentPage(1);
    }

    setSortedProducts(sorted);
  };

  return (
    <>
      <Head>
        <title>
          Продукти - &nbsp;
          {router.query.brand ||
            router.query.category ||
            router.query.subCategory}
        </title>
        <meta name="description" content="Generated by create next app" />
      </Head>

      <div className="container my-3">
        <div className="row m-auto">
          <div className="col-12 d-flex justify-content-between align-items-center">
            <div
              className="filter-btn text-center"
              onClick={() => {
                toggleOpeningFilterMenu();
              }}>
              <img src="./filterLogo.png" alt="" />
            </div>
            <div className="d-flex">
              <p className="m-0">Подреди според: &nbsp;</p>
              <select
                name=""
                id=""
                className="px-2 rounded"
                onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {
                  event.preventDefault();
                  sortProducts(event.target.value);
                }}>
                <option value="сортирај">Сортирај</option>
                <option value="најново">Најново</option>
                <option value="најстаро">Најстаро</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      {openFilterMenu === true ? (
        <SideFilterMenu closeFilterMenu={closeFilterMenu} />
      ) : null}

      <div className="container">
        <div className="row mx-auto">
          {paginationProductsForDisplaying.length < 1 ? (
            <div className="col-12 text-center my-5">
              <h5>Бараните резултати не се достапни.</h5>
            </div>
          ) : (
            // paginationProductsForDisplaying.map((product, idx) => {
            //   return <Product key={`${product.id}-${idx}`} product={product} />;
            // })

            paginationProductsForDisplaying.map((product, idx) => {
              const productsToDisplay =
                sortedProducts.length > 0
                  ? sortedProducts
                  : paginationProductsForDisplaying;

              return (
                <Product
                  key={`${product.id}-${idx}`}
                  product={productsToDisplay[idx]}
                />
              );
            })
          )}

          {paginationProductsForDisplaying.length > 0 && (
            <div className="col-12 my-3">
              <div className="d-flex justify-content-center align-items-center">
                <button
                  className="mr-2 border-0 bg-transparent"
                  onClick={() => setCurrentPage(currentPage - 1)}>
                  <i className="fa-solid fa-chevron-left text-dark"></i>
                </button>
                {Array.from({ length: totalPages }, (undefined, index) => (
                  <span
                    className="m-0 p-0"
                    key={`${index}-${new Date().getTime()}`}>
                    <a
                      className={`${
                        currentPage === index + 1
                          ? "active-pagination-button"
                          : ""
                      } pagination-button releated-page-font mr-2`}
                      onClick={() => handlePage(index + 1)}>
                      {index + 1}
                    </a>
                  </span>
                ))}
                <button
                  className="border-0 bg-transparent"
                  onClick={() => setCurrentPage(currentPage + 1)}>
                  <i className="fa-solid fa-chevron-right text-dark"></i>
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </>
  );
};

export default ProductsPage;

export const getServerSideProps: GetServerSideProps = async ({ query }) => {
  let productRes: Response;

  if (
    query.category &&
    query.brand &&
    query.subCategory &&
    query.size &&
    query.color &&
    query.price &&
    query.q
  ) {
    productRes = await fetch(
      `http://localhost:5001/products?category=${query.category}&brand=${query.brand}&subCategory=${query.subCatdegory}&size=${query.size}&color=${query.color}&price=${query.price}&q=${query.q}`
    );
  } else if (query.category) {
    const categories = Array.isArray(query.category)
      ? query.category
      : [query.category];

    const categoryQueries = categories
      .map((category) => `category=${category}`)
      .join("&");

    productRes = await fetch(
      `http://localhost:5001/products?${categoryQueries}`
    );
  } else if (query.brand) {
    const brands = Array.isArray(query.brand) ? query.brand : [query.brand];

    const brandQueries = brands.map((brand) => `brand=${brand}`).join("&");

    productRes = await fetch(`http://localhost:5001/products?${brandQueries}`);
  } else if (query.subCategory) {
    const subCategory = Array.isArray(query.subCategory)
      ? query.subCategory
      : [query.subCategory];

    const subCategoryQueries = subCategory
      .map((subCategory) => `subCategory=${subCategory}`)
      .join("&");

    productRes = await fetch(
      `http://localhost:5001/products?${subCategoryQueries}`
    );
  } else if (query.color) {
    const colors = Array.isArray(query.color) ? query.color : [query.color];

    const colorQueries = colors.map((color) => `color=${color}`).join("&");

    productRes = await fetch(`http://localhost:5001/products?${colorQueries}`);
  } else if (query.size) {
    const sizes = Array.isArray(query.size) ? query.size : [query.size];

    const sizeQueries = sizes.map((size) => `size=${size}`).join("&");

    productRes = await fetch(`http://localhost:5001/products?${sizeQueries}`);
  } else if (query.price) {
    const prices = Array.isArray(query.price) ? query.price : [query.price];

    const priceQueries = prices.map((price) => price).join("&");

    productRes = await fetch(`http://localhost:5001/products?${priceQueries}`);
  } else if (query.q) {
    productRes = await fetch(`http://localhost:5001/products?q=${query.q}`);
  } else {
    productRes = await fetch(`http://localhost:5001/products`);
  }

  const productData: ProductType[] = await productRes.json();

  return {
    props: { productData },
  };
};
